@isTest
private class CourseCreateEnquiryUtilityTest {

    private static final String ACCOUNT_BRANCH_RECORDTYPE = 'Branch';
    private static final String CONTACT_POSTCODE = 'E1 7AE';
    private static final String CONTACT_EMAIL = 'test@test.test';
    private static final String HEADERS = '{"Content-Type":"application/x-www-form-urlencoded"}';
    private static final String PARAMS = '{"email":"' + CONTACT_EMAIL + '","hearaboutus":"NCT website or event","first_name":"Test",' + 
                                         '"duedate":"30/09/2019","firstbaby":"1","address_line1":"Test","address_line2":"",' +
                                         '"additioninfo":"","title":"Mr","last_name":"Test","form_id":"course_enquiry_form",' +
                                         '"twinsexpected":"0","county":"UK","postcode":"' + CONTACT_POSTCODE + '","mobile":"+442072343456",' +
                                         '"town":"London","op":"Send enquiry"}';
    
    //@testSetup
    // avoid annotation - Account.AccountAutoNumber is not unique when using @TestSetup
    static void createTestData() {
        List<OrgWideEmailAddress> addresses = [
            SELECT Id, Address 
            FROM OrgWideEmailAddress
            LIMIT 1
        ];

        String existingAddress = addresses[0].Address;

        TestDataFactory.getInstance()
            .buildBranchAccountWithEmails(existingAddress)
            .buildOrganizationAccount('acct1')
            .buildPractitioner('Test')
            .buildPractitionerFeeRate()
            .buildVenue()
            .buildRoom()
            .buildLicenceToPractice()
            .buildCoursesWithSessions(2, 2);


        Profile p = [SELECT Id FROM Profile WHERE Name='Website Integration'];
        String uniqueUserName = 'websiteuser' + DateTime.now().getTime() + '@testorg.com';
        User u = new User(
            Alias = 'websiteu',
            Email='websiteuser@testorg.com',
            EmailEncodingKey='UTF-8',
            LastName='websiteuserTesting',
            LanguageLocaleKey='en_US',
            LocaleSidKey='en_GB',
            ProfileId = p.Id,
            TimeZoneSidKey='Europe/London',
            UserName=uniqueUserName
        );  
        insert u;

        TestDataFactory dataFactory = TestDataFactory.getInstance();
        List<Course__c> coursesToFinal = [
            SELECT Status__c, Count_of_Estimated_Travel_Costs__c, Count_of_Estimated_Venue_Costs__c, Main_Venue__c, Fee__c,
            (
                SELECT Status__c FROM Sessions__r
            )
            FROM Course__c
        ];

        Id recordTypeId = Schema.SObjectType.Account.getRecordTypeInfosByDeveloperName().get(ACCOUNT_BRANCH_RECORDTYPE).getRecordTypeId();
        Account branch = [
           SELECT Id 
           FROM Account 
           WHERE RecordTypeId = :recordTypeId
           LIMIT 1
        ];
        
        TestVenueBuilder venueBuilder = new TestVenueBuilder();
        Venue__c mainVenue = venueBuilder
                                .withBranch(branch)
                                .insertRecord(true)
                                .build();

        dataFactory.setMainVenueToCourses(mainVenue, coursesToFinal);
        for (Course__c course : coursesToFinal) {
            if (!course.Sessions__r.isEmpty()) {
                dataFactory.setSessionsToConfirmed(course.Sessions__r);   
            }
        }
        dataFactory.setCoursesWithSessionsToFinal(coursesToFinal);
    }

    @isTest
    static void createEnquiryWithoutExistingContact() {
        createTestData();
        String avaliableCourse = [
            SELECT Id, Name
            FROM Course__c 
        ][0].Name;
        Map<String, String> paramsMap = (Map<String, String>)JSON.deserialize(PARAMS, Map<String, String>.class);
        paramsMap.put('courseId', avaliableCourse);
        CourseCreateEnquiryUtility.createEnquiry(paramsMap);
        List<Contact> createdContact = [
            SELECT Name, Email 
            FROM Contact 
            WHERE Email =: CONTACT_EMAIL
        ];
        List<Booking__c> bookings = [
            SELECT Name 
            FROM Booking__c
        ];
        System.assertEquals(1, createdContact.size());
        System.assertEquals(1, bookings.size());
    }
    
    @isTest
    static void createEnquiryWithExistingContact() {
        createTestData();
        String avaliableCourse = [
            SELECT Id, Name
            FROM Course__c 
        ][0].Name;
        Account account = new Account(
            RecordTypeId = Schema.Sobjecttype.Account.getRecordTypeInfosByName().get('Household Account').getRecordTypeId(),
            Name = 'Test Household'
        );
        insert account;
        Contact existingContact = createExistingContact(account.Id);
        Map<String, String> paramsMap = (Map<String, String>)JSON.deserialize(PARAMS, Map<String, String>.class);
        paramsMap.put('courseId', avaliableCourse);
        CourseCreateEnquiryUtility.createEnquiry(paramsMap);
        List<Contact> contacts = [
            SELECT Name
            FROM Contact
            WHERE Email =: CONTACT_EMAIL
        ];
        List<Booking__c> bookings = [
            SELECT Name 
            FROM Booking__c
        ];
        System.assertEquals(1, contacts.size(), 'There should be only 1 Contact because we have duplication rule');
        System.assertEquals(1, bookings.size());
    }

    @isTest
    static void createEnquiryWithExistingContactAndPartner() {
        createTestData();
        Account accountPartner = new Account(
            RecordTypeId = Schema.Sobjecttype.Account.getRecordTypeInfosByName().get('Household Account').getRecordTypeId(),
            Name = 'Partner Household'
        );
        insert accountPartner;
        TestContactBuilder contactBuilder = new TestContactBuilder();
        Contact partner = contactBuilder
            .withRecordType('Client')
            .withLastName('Partner')
            .withFirstName('Partner')
            .withEmail('partner@partner.partner')
            .withMailingPostalCode(CONTACT_POSTCODE)
            .withAccount(accountPartner)
            .insertRecord(false)
            .build();
        insert partner;
        Account account = new Account(
            RecordTypeId = Schema.Sobjecttype.Account.getRecordTypeInfosByName().get('Household Account').getRecordTypeId(),
            Name = 'Test Household'
        );
        insert account;
        Contact existingContact = createExistingContact(account.Id);
        String avaliableCourse = [
            SELECT Id, Name
            FROM Course__c 
        ][0].Name;
        Map<String, String> paramsMap = (Map<String, String>)JSON.deserialize(PARAMS, Map<String, String>.class);
        paramsMap.put('courseId', avaliableCourse);
        paramsMap.put('partner_first_name', 'Partner');
        paramsMap.put('partner_last_name', 'Partner');
        paramsMap.put('partner_email', 'partner@partner.partner');
        paramsMap.put('postcode', CONTACT_POSTCODE);
        
        // Temporarily commented to avoid System.LimitException: npsp:Too many SOQL queries: 101
        // To be fixed in T-02067
        Test.startTest();
            CourseCreateEnquiryUtility.createEnquiry(paramsMap);
        Test.stopTest();
        List<Contact> partners = [
            SELECT Name, Email
            FROM Contact
            WHERE Email =: paramsMap.get('partner_email')
        ];
        List<Contact> mainContacts = [
            SELECT Name, Email
            FROM Contact
            WHERE Email =: paramsMap.get('email')
        ];
        List<Booking__c> bookings = [
            SELECT Name
            FROM Booking__c
            WHERE Partner_Contact__c != null
        ];
        System.assertEquals(1, partners.size());
        System.assertEquals(1, mainContacts.size());
        System.assertEquals(1, bookings.size());
    }

    @isTest
    static void createEnquiryWithoutExistingPartner() {
        createTestData();
        Account account = new Account(
            RecordTypeId = Schema.Sobjecttype.Account.getRecordTypeInfosByName().get('Household Account').getRecordTypeId(),
            Name = 'Test Household'
        );
        insert account;
        Contact existingContact = createExistingContact(account.Id);
        String avaliableCourse = [
            SELECT Id, Name 
            FROM Course__c 
        ][0].Name;
        Map<String, String> paramsMap = (Map<String, String>)JSON.deserialize(PARAMS, Map<String, String>.class);
        paramsMap.put('courseId', avaliableCourse);
        paramsMap.put('partner_first_name', 'Partner');
        paramsMap.put('partner_last_name', 'Partner');
        paramsMap.put('partner_email', 'partner@partner.partner');
        Test.startTest();

        CourseCreateEnquiryUtility.createEnquiry(paramsMap);

        Test.stopTest();
        List<Contact> partners = [
            SELECT Name, Email
            FROM Contact
            WHERE Email =: paramsMap.get('partner_email')
        ];
        List<Booking__c> bookings = [
            SELECT Name
            FROM Booking__c
            WHERE Partner_Contact__c != null
        ];
        System.assertEquals(1, partners.size());
        System.assertEquals(1, bookings.size());
    }

    @isTest
    static void createEnquiryWithContactPreference() {
        createTestData();
        String avaliableCourse = [
            SELECT Id, Name
            FROM Course__c 
        ][0].Name;
        Map<String, String> paramsMap = (Map<String, String>)JSON.deserialize(PARAMS, Map<String, String>.class);
        paramsMap.put('courseId', avaliableCourse);
        paramsMap.put('emailPreference', '1');
        CourseCreateEnquiryUtility.createEnquiry(paramsMap);
        List<Contact> createdContact = [
            SELECT Name, Email, Individual.Email__c
            FROM Contact 
            WHERE Email =: CONTACT_EMAIL
        ];
        List<Booking__c> bookings = [
            SELECT Name
            FROM Booking__c
        ];
        System.assertEquals(true, createdContact[0].Individual.Email__c, 'Contact email preference should be marked as true according to test case');
    }

    @isTest
    static void createEnquiryWithoutExistingPartnerWithContactPreference() {
        createTestData();
        Account account = new Account(
            RecordTypeId = Schema.Sobjecttype.Account.getRecordTypeInfosByName().get('Household Account').getRecordTypeId(),
            Name = 'Test Household'
        );
        insert account;
        Contact existingContact = createExistingContact(account.Id);
        String avaliableCourse = [
            SELECT Id, Name 
            FROM Course__c 
        ][0].Name;
        Map<String, String> paramsMap = (Map<String, String>)JSON.deserialize(PARAMS, Map<String, String>.class);
        paramsMap.put('courseId', avaliableCourse);
        paramsMap.put('partner_first_name', 'Partner');
        paramsMap.put('partner_last_name', 'Partner');
        paramsMap.put('partner_email', 'partner@partner.partner');
        paramsMap.put('courseId', avaliableCourse);
        paramsMap.put('emailPreference', '1');
        Test.startTest();

        CourseCreateEnquiryUtility.createEnquiry(paramsMap);
        
        Test.stopTest();
        List<Contact> partners = [
            SELECT Name, Email, Individual.Email__c
            FROM Contact
            WHERE Email =: paramsMap.get('partner_email')
        ];
        List<Booking__c> bookings = [
            SELECT Name
            FROM Booking__c
            WHERE Partner_Contact__c != null
        ];
        System.assertEquals(true, partners[0].Individual.Email__c);
    }

    @isTest
    static void createEnquiryWithThreeExistingPrimaryContacts() {
        createTestData();
        Account[] accounts = new Account[]{};
        Contact[] contacts = new Contact[]{};
        for (Integer i = 0; i < 3; i++) {
            accounts.add(new Account(
                RecordTypeId = Schema.Sobjecttype.Account.getRecordTypeInfosByName().get('Household Account').getRecordTypeId(),
                Name = 'Test Household' + i
            ));
        }
        insert accounts;

        for (Integer i = 0; i < 3; i++) {
            contacts.add(new Contact(
                LastName = 'Test',  
                FirstName = 'Test', 
                Email = CONTACT_EMAIL,
                MailingCity = 'London',
                MailingStreet = '221B Baker Street',
                MailingPostalCode = CONTACT_POSTCODE,
                npe01__PreferredPhone__c = 'Mobile',
                MobilePhone = '+447911123456',
                AccountId = accounts[i].Id,
                RecordTypeId = SObjectType.Contact.getRecordTypeInfosByDeveloperName().get(CourseCreateEnquiryUtility.RECORDTYPE_NAME).getRecordTypeId()
            )); 
        }
        
        Database.DMLOptions dmlOption = new Database.DMLOptions();
        dmlOption.DuplicateRuleHeader.AllowSave = true;
        Database.insert(contacts, dmlOption);

        String avaliableCourse = [
            SELECT Id, Name 
            FROM Course__c 
        ][0].Name;
        Map<String, String> paramsMap = (Map<String, String>)JSON.deserialize(PARAMS, Map<String, String>.class);
        paramsMap.put('courseId', avaliableCourse);
        paramsMap.put('emailPreference', '1');
        CourseCreateEnquiryUtility.createEnquiry(paramsMap);
        List<Contact> duplicates = [
            SELECT Email
            FROM Contact
            WHERE Email =: CONTACT_EMAIL
        ];
        List<Booking__c> bookings = [
            SELECT Name
            FROM Booking__c
        ];
        System.assertEquals(1, bookings.size());
        System.assertEquals(4, duplicates.size());
    }

    @isTest
    static void createEnquiryWithThreeExistingPartners() {
        createTestData();
        Account[] accounts = new Account[]{};
        Contact[] contacts = new Contact[]{};
        for (Integer i = 0; i < 3; i++) {
            accounts.add(new Account(
                RecordTypeId = Schema.Sobjecttype.Account.getRecordTypeInfosByName().get('Household Account').getRecordTypeId(),
                Name = 'Test Household' + i
            ));
        }
        insert accounts;

        for (Integer i = 0; i < 3; i++) {
            contacts.add(new Contact(
                LastName = 'Partner',  
                FirstName = 'Partner', 
                Email = 'partner@partner.partner',
                MailingCity = 'London',
                MailingStreet = '221B Baker Street',
                MailingPostalCode = CONTACT_POSTCODE,
                npe01__PreferredPhone__c = 'Mobile',
                MobilePhone = '+447911121337',
                AccountId = accounts[i].Id,
                RecordTypeId = SObjectType.Contact.getRecordTypeInfosByDeveloperName().get(CourseCreateEnquiryUtility.RECORDTYPE_NAME).getRecordTypeId()
            )); 
        }
        
        Database.DMLOptions dmlOption = new Database.DMLOptions();
        dmlOption.DuplicateRuleHeader.AllowSave = true;
        Database.insert(contacts, dmlOption);

        String avaliableCourse = [
            SELECT Id, Name 
            FROM Course__c 
        ][0].Name;
        Map<String, String> paramsMap = (Map<String, String>)JSON.deserialize(PARAMS, Map<String, String>.class);
        paramsMap.put('courseId', avaliableCourse);
        paramsMap.put('partner_first_name', 'Partner');
        paramsMap.put('partner_last_name', 'Partner');
        paramsMap.put('partner_email', 'partner@partner.partner');
        CourseCreateEnquiryUtility.createEnquiry(paramsMap);
        List<Contact> partners = [
            SELECT Name, Email
            FROM Contact
            WHERE Email =: paramsMap.get('partner_email')
        ];
        List<Booking__c> bookings = [
            SELECT Name
            FROM Booking__c
        ];
        System.assertEquals(4, partners.size());
        System.assertEquals(1, bookings.size());
    }
    private static Contact createExistingContact(Id accountId) {
        Contact existingContact = new Contact(
            LastName = 'Test',  
            FirstName = 'Test', 
            Email = CONTACT_EMAIL,
            MailingCity = 'London',
            MailingStreet = '221B Baker Street',
            MailingPostalCode = CONTACT_POSTCODE,
            npe01__PreferredPhone__c = 'Mobile',
            MobilePhone = '+447911123456',
            AccountId = accountId,
            RecordTypeId = SObjectType.Contact.getRecordTypeInfosByDeveloperName().get(CourseCreateEnquiryUtility.RECORDTYPE_NAME).getRecordTypeId()
        );
        insert existingContact;
        return existingContact;
    }
}